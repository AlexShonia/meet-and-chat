{% extends "base.html" %} {% block content %} {{ user_id|json_script:"user-id"}}
{% include "components/chat-box.html" with voice_chat=True %}
<script>
  class SoundMeter {
    constructor(context) {
      this.context = context;
      this.instant = 0.0;
      this.script = context.createScriptProcessor(2048, 1, 1);

      this.script.onaudioprocess = (event) => {
        const input = event.inputBuffer.getChannelData(0);
        let sum = 0.0;

        for (let i = 0; i < input.length; ++i) {
          sum += input[i] * input[i];
        }

        this.instant = Math.sqrt(sum / input.length);
      };
    }

    connectToSource(stream, callback) {
      try {
        this.mic = this.context.createMediaStreamSource(stream);
        this.mic.connect(this.script);
        this.script.connect(this.context.destination); // required for processing to run
        if (typeof callback !== "undefined") {
          callback(null);
        }
      } catch (e) {
        console.error(e);
        if (typeof callback !== "undefined") {
          callback(e);
        }
      }
    }

    stop() {
      if (this.mic) {
        this.mic.disconnect();
      }
      this.script.disconnect();
    }
  }

  function toggleTheme() {
    const root = document.documentElement;
    const currentTheme = root.getAttribute("data-theme");
    const newTheme = currentTheme === "dark" ? "light" : "dark";
    root.setAttribute("data-theme", newTheme);
    localStorage.setItem("theme", newTheme);
  }

  // Set initial theme from localStorage or default to dark
  document.addEventListener("DOMContentLoaded", () => {
    const savedTheme = localStorage.getItem("theme") || "dark";
    document.documentElement.setAttribute("data-theme", savedTheme);
  });

  const userID = JSON.parse(document.getElementById("user-id").textContent);

  const ws_scheme = window.location.protocol === "https:" ? "wss://" : "ws://";

  let remoteAudio;
  let stream;
  let localAudioTrack;
  let chatColor = "#FF6B6B";
  let msgUserID;
  let chatStarted = false;
  let peerConnection;
  const controlBtn = document.querySelector("#control-btn");

  const chatSocket = new WebSocket(
    ws_scheme + window.location.host + "/ws/voice-chat/"
  );

  const matchSound = document.getElementById("match-sound");
  matchSound.volume = 0.3;

  const openMediaDevices = async (constraints) => {
    return await navigator.mediaDevices.getUserMedia(constraints);
  };

  (async () => {
    try {
      try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.audioContext = new AudioContext();
      } catch (e) {
        alert("Web Audio API not supported.");
      }

      stream = await openMediaDevices({ video: false, audio: true });
      localAudioTrack = stream.getAudioTracks()[0];

      const soundMeter = (window.soundMeter = new SoundMeter(
        window.audioContext
      ));
      soundMeter.connectToSource(stream, function (e) {
        if (e) {
          alert(e);
          return;
        }
        meterRefresh = setInterval(() => {
          const fillRect = document.getElementById("volume-fill");
          const fillPath = document.getElementById("volume-fill-color");
          const volume = soundMeter.instant;
          const maxHeight = 16;
          const fillHeight = Math.min(maxHeight, volume * 200);
          const fillY = maxHeight - fillHeight;

          fillRect.setAttribute("y", fillY);
          fillRect.setAttribute("height", fillHeight);
          fillPath.setAttribute("fill", chatColor);
        }, 200);
      });
    } catch (error) {
      console.error("Error accessing media devices.", error);
    }
  })();

  async function handleChatMessage(data) {
    const message = data.message;
    const user = data.user;
    const messageUserID = data.user_id;
    const event = data.event;
    const chat_color = data.chat_color;

    switch (event) {
      case "message":
        chatColor = chat_color;
        document.querySelector(
          "#chat-messages"
        ).innerHTML += `<div class="message-container">
                <span class="user-name" style="color: ${chat_color}">${user}:</span>
                <span class="message">${message}</span>
              </div>`;
        break;
      case "info":
        chatColor = chat_color;
        break;
      case "start":
        chatStarted = true;
        document.querySelector("#status").innerHTML = "Searching...";
        chatColor = chat_color;
        controlBtn.textContent = "Stop";
        break;
      case "stop":
        peerConnection.close();
        peerConnection = null;
        chatStarted = false;
        chatColor = chat_color;
        controlBtn.textContent = "Start";

        matchSound.play();
        document.querySelector(
          "#chat-messages"
        ).innerHTML += `<div class="system-message"><span style="color: ${chat_color}">${user}</span> left the chat</div>`;
        document.querySelector("#status").innerHTML = `${user} left the chat`;

        break;
      case "join":
        chatStarted = true;
        matchSound.play();
        document.querySelector("#chat-messages").innerHTML = "";
        document.querySelector(
          "#chat-messages"
        ).innerHTML += `<div class="system-message"><span style="color: ${chat_color}">${user}</span> joined the chat</div>`;
        if (userID == messageUserID) {
          chatColor = chat_color;
        }
        document.querySelector(
          "#status"
        ).innerHTML = `You were paired, say hi!`;

        msgUserID = messageUserID;
        await makeCall();
        break;
      case "image":
        const imgContainer = document.createElement("div");
        imgContainer.className = "message-container";
        imgContainer.innerHTML = `<span class="user-name" style="color: ${chat_color}">${user}:</span>
              <img src="${window.location.origin}${message}" style="max-width: 300px; max-height: 300px; object-fit: contain;"></img>`;
        document.querySelector("#chat-messages").appendChild(imgContainer);
        const img = imgContainer.querySelector("img");
        img.onload = function () {
          const chatLog = document.querySelector("#chat-messages");
          chatLog.scrollTop = chatLog.scrollHeight;
        };
        break;
    }

    const chatLog = document.querySelector("#chat-messages");
    if (event !== "image") {
      chatLog.scrollTop = chatLog.scrollHeight;
    }
  }
  async function makeCall() {
    const amCaller = userID != msgUserID;
    const configuration = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun3.l.google.com:3478" },
        { urls: "stun:stun3.l.google.com:19302" },
      ],
    };
    peerConnection = new RTCPeerConnection(configuration);

    let pendingCandidates = [];
    let remoteDescriptionSet = false;

    chatSocket.onmessage = async (e) => {
      const data = JSON.parse(e.data);

      if (data?.answer && amCaller) {
        await peerConnection.setRemoteDescription(data.answer);
        remoteDescriptionSet = true;

        for (const candidate of pendingCandidates) {
          await peerConnection.addIceCandidate(candidate);
        }
        pendingCandidates = [];
      }

      if (data?.offer && !amCaller) {
        await peerConnection.setRemoteDescription(data.offer);
        remoteDescriptionSet = true;

        const answer = await peerConnection.createAnswer();
        chatSocket.send(JSON.stringify({ type: "answer", answer: answer }));
        await peerConnection.setLocalDescription(answer);

        for (const candidate of pendingCandidates) {
          await peerConnection.addIceCandidate(candidate);
        }
        pendingCandidates = [];
      }

      if (data?.iceCandidate) {
        if (remoteDescriptionSet) {
          try {
            await peerConnection.addIceCandidate(data.iceCandidate);
          } catch (e) {
            console.error("Error adding received ICE candidate", e);
          }
        } else {
          pendingCandidates.push(data.iceCandidate);
        }
      }

      await handleChatMessage(data);
    };

    peerConnection.onconnectionstatechange = (event) => {
      if (peerConnection.connectionState === "connected") {
        // Maybe show somehow in UI
      }
    };

    remoteAudio = new Audio();
    remoteAudio.autoplay = true;

    peerConnection.addEventListener("track", (event) => {
      const [remoteStream] = event.streams;
      remoteAudio.srcObject = remoteStream;
    });

    stream.getAudioTracks().forEach((track) => {
      peerConnection.addTrack(track, stream);
    });

    peerConnection.addEventListener("icecandidate", (event) => {
      if (event.candidate) {
        chatSocket.send(
          JSON.stringify({
            type: "ice_candidate",
            "new-ice-candidate": event.candidate,
          })
        );
      }
    });

    if (amCaller) {
      await new Promise((r) => setTimeout(r, 100));
      const offer = await peerConnection.createOffer();

      chatSocket.send(JSON.stringify({ type: "offer", offer: offer }));
      await peerConnection.setLocalDescription(offer);
    }
  }

  chatSocket.onmessage = async (e) => {
    const data = JSON.parse(e.data);
    const message = data.message;
    await handleChatMessage(data);
  };

  chatSocket.onclose = function (e) {
    console.error("Chat socket closed unexpectedly");
  };

  document.querySelector("#go-back-btn").onclick = function (e) {
    window.history.back();
  };

  document.querySelector("#chat-message-input").focus();
  document.querySelector("#chat-message-input").onkeyup = function (e) {
    if (e.key === "Enter") {
      document.querySelector("#chat-message-submit").click();
    }
  };

  document.querySelector("#chat-message-submit").onclick = function (e) {
    const messageInputDom = document.querySelector("#chat-message-input");
    const message = messageInputDom.value;
    if (message.trim()) {
      chatSocket.send(
        JSON.stringify({
          message: message,
          type: "message",
        })
      );
      messageInputDom.value = "";
    }
  };

  document.getElementById("myFile").addEventListener("change", function (e) {
    if (this.files && this.files[0]) {
      const formData = new FormData();
      formData.append("filename", this.files[0]);
      formData.append(
        "csrfmiddlewaretoken",
        document.querySelector("[name=csrfmiddlewaretoken]").value
      );

      fetch("{% url 'upload_image'%}", {
        method: "POST",
        body: formData,
        headers: {
          "X-CSRFToken": document.querySelector("[name=csrfmiddlewaretoken]")
            .value,
        },
      })
        .then((response) => response.json())
        .then((data) => {
          if (data.file) {
            chatSocket.send(
              JSON.stringify({
                message: data.file,
                type: "image",
              })
            );
          }
        })
        .catch((error) => {
          console.error("Error:", error);
        });
    }
  });

  function toggleMic() {
    const micToggle = document.getElementById("mic-toggle");
    const isMuted = micToggle.getAttribute("data-muted") === "true";
    if (localAudioTrack) {
      localAudioTrack.enabled = isMuted;
    }

    if (isMuted) {
      micToggle.innerHTML = `
          <svg
            xmlns="http://www.w3.org/2000/svg"
            id="mic-svg"
            width="64"
            height="64"
            viewBox="0 0 16 16"
            fill="none"
          >
            <defs>
              <clipPath id="mic-clip">
                <!-- Fill bottom half: from y = 8 to y = 16 -->
                <rect id="volume-fill" x="0" y="8" width="16" height="8" />
              </clipPath>
            </defs>

            <!-- Background mic shape -->
            <path
              id="path-bg"
              d="M5 3C5 1.34315 6.34315 0 8 0C9.65685 0 11 1.34315 11 3V7C11 8.65685 9.65685 10 8 10C6.34315 10 5 8.65685 5 7V3Z"
            />
            <path
              id="path-bg"
              d="M9 13.9291V16H7V13.9291C3.60771 13.4439 1 10.5265 1 7V6H3V7C3 9.76142 5.23858 12 8 12C10.7614 12 13 9.76142 13 7V6H15V7C15 10.5265 12.3923 13.4439 9 13.9291Z"
            />

            <!-- Colored mic overlay, clipped to bottom half -->
            <g id="volume-fill-color" clip-path="url(#mic-clip)">
              <path
                d="M5 3C5 1.34315 6.34315 0 8 0C9.65685 0 11 1.34315 11 3V7C11 8.65685 9.65685 10 8 10C6.34315 10 5 8.65685 5 7V3Z"
              />
              <path
                d="M9 13.9291V16H7V13.9291C3.60771 13.4439 1 10.5265 1 7V6H3V7C3 9.76142 5.23858 12 8 12C10.7614 12 13 9.76142 13 7V6H15V7C15 10.5265 12.3923 13.4439 9 13.9291Z"
              />
            </g>
          </svg>
          `;
      micToggle.setAttribute("data-muted", "false");
    } else {
      micToggle.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="800px" height="800px" viewBox="0 0 16 16" fill="none">
            <path id="path-bg" d="M16 16H13L10.8748 13.3843C10.2884 13.6488 9.65899 13.8349 9 13.9291V16H7V13.9291C3.60771 13.4439 1 10.5265 1 7V6H3V7C3 9.76142 5.23858 12 8 12C8.54134 12 9.06258 11.914 9.55081 11.7548L8.12299 9.99753C8.0822 9.99917 8.0412 10 8 10C6.34315 10 5 8.65685 5 7V6.15385L0 0H3L16 16Z" fill="#000000"/>
            <path id="path-bg" d="M11 6.15385L6.38367 0.472212C6.85016 0.173309 7.40484 0 8 0C9.65685 0 11 1.34315 11 3V6.15385Z" fill="#000000"/>
            <path id="path-bg" d="M12.8076 8.37853L14.2506 10.1546C14.7299 9.20663 15 8.13485 15 7V6H13V7C13 7.47815 12.9329 7.94063 12.8076 8.37853Z" fill="#000000"/>
            </svg>
          `;
      micToggle.setAttribute("data-muted", "true");
    }
  }

  function toggleAudio() {
    const audioToggle = document.getElementById("audio-toggle");
    const isMuted = audioToggle.getAttribute("data-muted") === "true";

    if (isMuted) {
      audioToggle.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="800px" height="800px" viewBox="0 0 16 16" fill="none">
              <path id="path-bg" d="M6 1H8V15H6L2 11H0V5H2L6 1Z" fill="#000000"/>
              <path id="path-bg" d="M14 8C14 5.79086 12.2091 4 10 4V2C13.3137 2 16 4.68629 16 8C16 11.3137 13.3137 14 10 14V12C12.2091 12 14 10.2091 14 8Z" fill="#000000"/>
              <path id="path-bg" d="M12 8C12 9.10457 11.1046 10 10 10V6C11.1046 6 12 6.89543 12 8Z" fill="#000000"/>
            </svg>
          `;
      audioToggle.setAttribute("data-muted", "false");
      matchSound.volume = 0.3;
      if (remoteAudio) {
        remoteAudio.volume = 1;
      }
    } else {
      audioToggle.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="800px" height="800px" viewBox="0 0 16 16" fill="none">
              <path id="path-bg" d="M8 1H6L2 5H0V11H2L6 15H8V1Z" fill="#000000"/>
              <path id="path-bg" d="M9.29289 6.20711L11.0858 8L9.29289 9.79289L10.7071 11.2071L12.5 9.41421L14.2929 11.2071L15.7071 9.79289L13.9142 8L15.7071 6.20711L14.2929 4.79289L12.5 6.58579L10.7071 4.79289L9.29289 6.20711Z" fill="#000000"/>
            </svg>
          `;
      audioToggle.setAttribute("data-muted", "true");
      matchSound.volume = 0;
      if (remoteAudio) {
        remoteAudio.volume = 0;
      }
    }
  }

  function queueController() {
    if (chatStarted) {
      chatSocket.send(
        JSON.stringify({
          type: "stop",
        })
      );
    } else {
      chatSocket.send(
        JSON.stringify({
          type: "start",
        })
      );
      controlBtn.textContent = "Stop";
    }
  }
</script>
{% endblock %}
